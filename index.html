<html>
  <head>
  </head>
  <body>
    <div id="parent" style="position:relative; cursor:none;"></div>
    <script>

      //TO DO place in separate files. one for objects. one for variables and functions
      //TO DO add UI layer, player score, player health, weapons loadout

      //declaration
      var numCanvases = 32;    //defines amount of layers
      var canvasBag = [];      //holds canvas documents
      var contextBag = [];     //holds canvas contexts
      var startTime;           //for determining time elapsed during a frame
      var spawnClock = 0;      //temp variables to keep events
      var fireTimer = 10;      //triggering each frame
      var playerCanvas;        //canvas for player character
      var playerContext;       //context for player canvas 
      var player;              //player character object
      var canvasObjects = [];  //holds the arrays that hold the objects for each canvas layer
      //TO DO make separate canvas for player weapons

      //object types
      class GameObject //anything in the game that can move
      {
        constructor(context, xPos, yPos, zPos, xVel, yVel, zVel)
        {
          this.context = context;
          this.xPos = xPos;
          this.yPos = yPos; 
          this.zPos = zPos; 
          this.xVel = xVel;
          this.yVel = yVel;
          this.zVel = zVel;
        }
      }

      class Entity extends GameObject  //anything in the game that collides
      {                                //expect for the player character 
        constructor(context, xPos, yPos, zPos, xVel, yVel, zVel, scale, density)
        {
          super(context, xPos, yPos, zPos, xVel, yVel, zVel);
          this.scale = scale;
          this.density = density;
          this.isColliding = false;
        }
        draw()                         //determines where the object resides and draws it
        {                              //on the appropriate canvas at a corresponding color
          for(var i = 0; i < numCanvases; i++)
          {
          var num = (256/numCanvases)*i;
          var color = '#' + num.toString(16) + '0000';
          if(this.context==contextBag[numCanvases-1-i]){this.context.fillStyle = color;}
          } 
          this.context.beginPath();    //draw circle                         
          this.context.arc(this.xPos, this.yPos, this.scale, 0, 2*Math.PI);
          this.context.fill();
        }
        update(seconds)
        {
          if(this.xVel != 0){this.xVel*=0.999;}  //friction
          if(this.yVel != 0){this.yVel*=0.999;}
          this.yVel += 0.1;                      //very weak simulated gravity 
          this.xPos += this.xVel*seconds;        //position updated by velocity
          this.yPos += this.yVel*seconds;        //in each spatial plane 
          this.zPos += this.zVel*seconds;
        }
      }
      class Player                    //player character object
      {
        constructor(context, xPos, yPos, xVel, yVel, scale)
        {
          this.context=context;
          this.xPos=xPos;
          this.yPos=yPos;
          this.xVel=xVel;
          this.yVel=yVel;
          this.xVec=0;                           //x and y component of the object's
          this.yVec=1;                           //normalized forward vector 
          this.firePointX=0;                     //point on the screen where the player
          this.firePointY=scale;                 //character's missiles originate
          this.scale=scale;
          this.angle=0;                          //angle of the player's forward vector in relation to true north 
        }
        draw()                                                 //TO DO upgrade player appearance
        {
          this.context.save();
          this.context.translate(this.xPos, this.yPos);        //move player canvas to new position
          this.context.fillStyle = '#FFAA00';                  //draw player thruster graphic 
          this.context.beginPath();
          this.context.arc(this.firePointX/-2, this.firePointY/-2, 14, 0, 2*Math.PI);
          this.context.fill();
          this.context.fillStyle = '#0000FF';                  //draw player fire point graphic
          this.context.beginPath();
          this.context.arc(this.firePointX, this.firePointY, 4, 0, 2*Math.PI);
          this.context.fill();
          this.context.rotate(this.angle);                     //rotate canvas to the player's rotation 
          this.context.fillStyle = '#00FF00';                  //draw main body of player character
          this.context.beginPath();
          this.context.arc(0, 0, this.scale, 0, 2*Math.PI);     
          this.context.fill();
          this.context.restore();          
        }
        update(seconds)
        {
          if(this.xVel != 0){this.xVel*=0.99;}                 //friction
          if(this.yVel != 0){this.yVel*=0.99;}
          this.xPos+=this.xVel;                                //position updated by velocity
          this.yPos+=this.yVel;
          this.xVec = Math.sin(this.angle);                    //calculate forward vector based on
          this.yVec = Math.cos(this.angle);                    //player character object's rotation
          this.firePointX=this.xVec*this.scale;                //calculate position of fire point
          this.firePointY=this.yVec*this.scale*(-1);           //based on forward vector
        }
      }

      function makeCanvasTags(amount)                          //create string containing all HTML canvas tags for placement in parent div tag
      {
        var temp = '';                                         //first canvas tag is a plain red background and no game objects are drawn onto it  
        temp += '<canvas id="canvas0" width="1024" height="768" style="border:1px solid lightgrey; background-color:red; position:absolute; left:0px; top:0px; z-index:1;"></canvas>';

        for(var i=0; i < amount; i++)                          //loop to create various layers that the game objects are drawn onto 
        {
          temp += '<canvas id="'
                + 'canvas' 
                + (i+1).toString() 
                + '" width="1024" height="768" style="border:1px solid lightgrey; background-color:transparent; position:absolute; left:0px; top:0px; z-index:' 
                + (i+2).toString() 
                + ';"></canvas>"';
        }
        temp += '<canvas id="' 
              + 'canvas' 
              + (amount+1).toString() 
              + '" width="1024" height="768" style="background-color:transparent; position:absolute; left:0px; top:0px; z-index:' 
              + (amount+2).toString() +';"></canvas>"';

        document.getElementById("parent").innerHTML = temp;    //last canvas tag is for drawing the player character. After it is added, the string is placed into the parent div
      } 
      
      function makeCanvases(amount)                            //fills the array that will hold the canvas documents with temp variables
      {
        for(var i=0; i < amount; i++)
        {
          var temp;
          canvasBag[i] = temp;
        }
      }
      function makeContexts(amount)                            //fills the array that will hold the canvas contexts with temp variables
      {
        for(var i=0; i < amount; i++)
        {
          var temp;
          contextBag[i] = temp;
        }
      }

      function linkContexts(amount)                            //places canvas documents into the canvasBag array
      {                                                        //so they can be accessed later, gets contexts from
        for(var i=0; i < amount; i++)                          //the canvas documents, and places them into the
        {                                                      //contextBag array so they can be accessed later 
          var temp = "canvas" + (i+1).toString();
          canvasBag[i] = document.getElementById(temp);
          contextBag[i] = canvasBag[i].getContext('2d');
        }
      }
      function makeLayers(amount)                              //fills the array with empty arrays that will be
      {                                                        //used to hold dynamically created game objects
        for(var i=0; i < amount; i++)
        {
          var temp = [];
          canvasObjects.push(temp);
        }
      }
      function init()                                             //creates conditions necessary for building the game
      {                                                              
        var playerTemp = 'canvas' + (numCanvases + 1).toString();
        makeCanvasTags(numCanvases);                              //makes all the canvases and arrays to hold canvas drawn  
        makeCanvases(numCanvases);                                //objects based on an amount which is a power of 2
        makeContexts(numCanvases);                                //wip, currently only works when this amount is 16
        linkContexts(numCanvases);                                //due to some hard coding and magic numbers
        makeLayers(numCanvases);
        playerCanvas = document.getElementById(playerTemp);       //creates player canvas, context, and object
        playerContext = playerCanvas.getContext('2d');
        player = new Player(playerContext, playerCanvas.width/2, playerCanvas.height/2, 0, 0, 20);
        document.addEventListener('mousedown', mouseDownHandler, false);
        document.addEventListener('keydown', keyDownHandler, false);                               //control input listeners
        document.addEventListener('keyup', keyUpHandler, false);
        window.requestAnimationFrame(gameLoop);                   //initiate recursive game loop
      }

      window.onload = init();                                     //initialize on window load

      function keyUpHandler(e)                                 //resets fire delay when space bar is release so missiles fire
      {                                                        //immediately when space bar is pressed
        var x = e.keyCode;

        if(x==32){fireTimer=10;}
      }

      function keyDownHandler(e)                               //handles input while various keys are held down
      {                                                        //this is placeholder until I can implement
        var x = e.keyCode;                                     //multiple simultaneous key presses

        switch(x)
        { 
          case 37:                                             //rotate player character left relative to player's
            player.angle-=0.1;                                 //forward vector with left arrow
            break; 
          case 38:                                             //move player character in direction of player's
            player.yVel+=0.01*player.firePointY;               //forward vector with up arrow
            player.xVel+=0.01*player.firePointX;               //TO DO limit MAX speed, constrain player to screen
            break;
          case 39:                                             //rotate player character right relative to player's
            player.angle+=0.1;                                 //forward vector with right arrow
            break;
        }
      }

      function mouseDownHandler()
      {fire();}

      function fire()                                          //dynamically create missle at player's fire point in the direction of player's forward vector
      {                                                        //when fire timer delay has successfully loop                        //TO DO add new weapons, weapons loadout, and weapon switching
     
          var spawn = new Entity(contextBag[numCanvases - 1], player.xPos+player.firePointX, player.yPos+player.firePointY, 100, player.firePointX*20, player.firePointY*20, 0, 10, 200);
          canvasObjects[numCanvases - 1].push(spawn);

      }
      function gameLoop(currentTime)                           //everything that occurs in the game during a given frame
      {
        var seconds = (currentTime - startTime)/1000;          //calculates the amount of time that has elapsed during a frame
        var framesPerSec = Math.round(1/seconds);
        startTime = currentTime;
        
        cleanUpLoop();

        spawnClock++                                           //temporary spawner delay
        if(spawnClock==2)
        {
          spawnerLoop();                                       //loop that creates various game objects that are not the player
          spawnClock = 0;                                      //nor a player missile
        }
        player.update(seconds);                                //player update
        updateLoop(seconds);                                   //update of all other game objects

        collisionLoop();                                       //collision calculations among all collidable game objects

        moveInZLoop();                                         //moves objects between canvas layers

        clearCanvases();                                       //removes last frame's information from the various canvases
        player.draw();                                         //draws this frame's player information to the player character canvas 
        drawLoop();                                            //draws this frame's non-player information to the various other canvases

        contextBag[numCanvases - 1].font = '25px Arial';       //temporary frames per second calculation display 
        contextBag[numCanvases - 1].fillStyle = 'black';
        contextBag[numCanvases - 1].fillText("fps: " + fireTimer, 10, 30);

        window.requestAnimationFrame(gameLoop);                //game loop function recursion
      }

      function spawnToCollide(spawnXPos,spawnYPos,sizeToSpawn,objects)  //checks to see if new object will collide with existing objects in a given canvas layer
      {
        var obj1;
        var obj2;
        var willCollide = false;
        
        for(i=0; i < objects.length;i++)
        {
          obj1 = objects[i];
          var diffX = spawnXPos-obj1.xPos;
          var diffY = spawnYPos-obj1.yPos;
          var sqDistance= Math.pow(diffX,2) + Math.pow(diffY,2);
          if (sqDistance <= Math.pow(obj1.scale + sizeToSpawn,2))
          {
              willCollide = true;
          }
        }
        return willCollide;
      } 

      var spawner = function(objects)                         //dynamically spawns objects using various random parameters within set ranges.
      {                                                       //input parameter is an array of objects in a given layer, to which the spawned
        var randomX = Math.floor(Math.random() * 1024);       //object is added
        var randomY = Math.floor((Math.random() * 768)-10);
        var randomZ;
        var ranXVel = Math.floor(Math.random() * 250)-125;
        var ranYVel = Math.floor(Math.random() * 200)-100;
        var ranZVel = Math.random() * 4;
        var ranSize = Math.floor(Math.random() * 90) + 10;
        var ranDensity = Math.floor(Math.random() * 50) + 1;
        var currentContext;
        if(objects==canvasObjects[numCanvases-1])                        //assigns a Z position based on the context of the objects in the input parameter array
        {
          currentContext = contextBag[numCanvases-1]; randomZ = Math.floor(Math.random() * 5 + 100);
        }
        else
        {
          for(var i=0; i < canvasObjects.length-1;i++)
          {
            if(objects==canvasObjects[i])
            {
              currentContext = contextBag[i]; 
              randomZ = Math.floor(Math.random() * (80/numCanvases)) + ((i+1)*(80/numCanvases));
            }
          }
        }
        if(!spawnToCollide(randomX, randomY, ranSize, objects))
        {
          var spawn = new Entity(currentContext, randomX, randomY, randomZ, ranXVel, ranYVel, ranZVel, ranSize, ranDensity);
          objects.push(spawn);
        }
      }

      function spawnerLoop()                                 //randomly chooses an array of objects from the "bottom" 6 game layers
      {                                                      //and passes it into the spawner function
        var ranCanvas = Math.floor(Math.random() * 5);
        spawner(canvasObjects[ranCanvas]);
      }

      function cleanUpOffScreen(objects)                     //checks if objects have strayed too far off screen and removes them
      {                                                      //from the appropriate object array, eliminating update of the given
        for(i=0; i < objects.length; i++)                    //object and allowing it to be garbage collected
        {
          var obj = objects[i];
          if((obj.xPos-obj.scale)>canvasBag[0].width||
             (obj.xPos+obj.scale)<0||
             (obj.yPos-obj.scale)>canvasBag[0].height||
             (obj.yPos+obj.scale*10)<0)
          {objects.splice(i,1);}
        }
      }

      function cleanUpLoop()                                 //sends each canvas layer object array into the clean up function
      {
        for(var i=0;i<canvasObjects.length;i++)
        { 
           cleanUpOffScreen(canvasObjects[i]);
        }
      }

      function updateLoop(delta)                             //input parameter is amount of time which has passed during a given frame
      {                                                      //which is then passed into the update function of each object in the game
        for(var i=0; i < canvasObjects.length; i++)          //that is not the player
        {
          group = canvasObjects[i];
          for(var j=0; j < group.length; j++)
          {
            group[j].update(delta);
          }  
        }
      }
      function moveInZ(objects)                              //moves objects between the various canvas layer object arrays based on their Z position value
      {
        for(var i = 0; i < objects.length; i++)
        {               
          for(var j = 0; j < canvasObjects.length; j++)
          {
            if(objects[i].zPos < (j+1)*(80/numCanvases) && (j+1)*(80/numCanvases) < 80)
            {
              objects[i].context = contextBag[j];
              canvasObjects[j].push(objects[i]);
              objects.splice(i,1);
              j = canvasObjects.length;
            }
            else if(objects[i].zPos >= (80 - (80/numCanvases)))
            {
              objects[i].context = contextBag[numCanvases-1];
              canvasObjects[numCanvases-1].push(objects[i]);
              objects.splice(i,1);
              j = canvasObjects.length;
            }
          }
        }              
      }
      function moveInZLoop()                                //sends all of the canvas layer object arrays into the moveInZ function to be checked
      {
        for(var i=0; i < canvasObjects.length;i++)
        {
          moveInZ(canvasObjects[i]);
        }
      }
      function detectCollision(objects)                     //detects collision between all collidable objects in a given canvas layer object array
      {                                                     //input parameter is a canvas layer object array
        var obj1;
        var obj2;                                           //TO DO handle overlapping objects, merging objects, splintering objects, and destroyed objects.
                                                            //TO DO check collision of game objects with player, implement damage system
        for(i=0; i < objects.length;i++)                    //resets each object's variable that indicates if the object is colliding with something else during a given frame
        {
          objects[i].isColliding = false;
        }

        for(i=0; i < objects.length;i++)                    //compares each object with every other object in the canvas layer object array
        {
          obj1 = objects[i];
          for(j=i+1; j < objects.length;j++)
          {
            obj2 = objects[j];
            var deltaX = obj2.xPos-obj1.xPos;
            var deltaY = obj2.yPos-obj1.yPos;
            var sqDistance= Math.pow(deltaX,2) + Math.pow(deltaY,2);
            if(sqDistance <= (Math.pow(obj1.scale + obj2.scale,2)))    //checks to see if the distance between two objects is less than equal to their combined radii
            {                                                          //thereby indicating a collision.
              obj1.isColliding=true;                                   //makes various physics calculations based on the parameters on the two objects in the collision
              obj2.isColliding=true;                                   //TO DO move into a function  
              var vNorm = {x: deltaX/Math.sqrt(sqDistance), y: deltaY/Math.sqrt(sqDistance)};
              var vRelVel = {x: obj1.xVel-obj2.xVel, y: obj1.yVel-obj2.yVel};
              var speed = (vRelVel.x * vNorm.x) + (vRelVel.y * vNorm.y);
              if (speed < 0){break;}
              var impulse = 2* speed / ((obj1.scale*obj1.density) + (obj2.scale*obj2.density));
              obj1.xVel -= (impulse*obj2.scale*obj2.density*vNorm.x);
              obj1.yVel -= (impulse*obj2.scale*obj2.density*vNorm.y);
              obj2.xVel += (impulse*obj1.scale*obj1.density*vNorm.x);
              obj2.yVel += (impulse*obj1.scale*obj1.density*vNorm.y);
            }
          }
        }
      }
      function collisionLoop()                                         //sends each canvas layer object array into the collision detection function
      {
        for(var i=0; i < canvasObjects.length;i++)
        {
          detectCollision(canvasObjects[i]);
        }
      }
      function clearCanvases()                                         //clears last frame's information from each canvas context 
      {
        for(i=0; i < contextBag.length; i++)
        {
          contextBag[i].clearRect(0,0,canvasBag[i].width,canvasBag[i].height);
        }
        playerContext.clearRect(0,0,playerCanvas.width,playerCanvas.height);
      }
      function drawLoop()                                              //draws every object in the game that is not the player
      {
        for(var i=0; i < canvasObjects.length; i++)
        {
          group = canvasObjects[i];
          for(var j=0; j < group.length; j++)
          {
            group[j].draw();
          }  
        }
      }
</script>
		
  </body>
</html>
